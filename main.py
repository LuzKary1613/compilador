tabla = {#DICCIONARIO DE LA TABLA DE TRANSICIÓN
    0:  {'letra': 7,  'num': 3,  'noSigma': 49, 'EOF': 49, '+': 32, '-': 2,  '*': 33, '/': 34, '<': 13, '=': 29, '>': 14, ':': 15, ';': 35, ',': 36, '\'': 1,  '.': 37, '_': 6,  '[': 38, ']': 39, '{': 12, '}': 40, '(': 9,  ')': 41, '\n': 0,  '\r': 0,  'space': 0},
    1:  {'letra': 1,  'num': 1,  'noSigma': 1,  'EOF': 42, '+': 1,  '-': 1,  '*': 1,  '/': 1,  '<': 1,  '=': 1,  '>': 1,  ':': 1,  ';': 1,  ',': 1,  '\'': 16, '.': 1,  '_': 1,  '[': 1,  ']': 1,  '{': 1,  '}': 1,  '(': 1,  ')': 1,  '\n': 43, '\r': 43, 'space': 1},
    2:  {'letra': 17, 'num': 3,  'noSigma': 44, 'EOF': 44, '+': 17, '-': 17, '*': 17, '/': 17, '<': 17, '=': 17, '>': 17, ':': 17, ';': 17, ',': 17, '\'': 17, '.': 17, '_': 17, '[': 17, ']': 17, '{': 17, '}': 17, '(': 17, ')': 17, '\n': 17, '\r': 17, 'space': 17},
    3:  {'letra': 18, 'num': 3,  'noSigma': 45, 'EOF': 45, '+': 18, '-': 18, '*': 18, '/': 18, '<': 18, '=': 18, '>': 18, ':': 18, ';': 18, ',': 18, '\'': 18, '.': 4,  '_': 18, '[': 18, ']': 18, '{': 18, '}': 18, '(': 18, ')': 18, '\n': 18, '\r': 18, 'space': 18},
    4:  {'letra': 47, 'num': 5,  'noSigma': 46, 'EOF': 46, '+': 47, '-': 47, '*': 47, '/': 47, '<': 47, '=': 47, '>': 47, ':': 47, ';': 47, ',': 47, '\'': 47, '.': 19, '_': 47, '[': 47, ']': 47, '{': 47, '}': 47, '(': 47, ')': 47, '\n': 47, '\r': 47, 'space': 47},
    5:  {'letra': 20, 'num': 5,  'noSigma': 48, 'EOF': 48, '+': 20, '-': 20, '*': 20, '/': 20, '<': 20, '=': 20, '>': 20, ':': 20, ';': 20, ',': 20, '\'': 20, '.': 20, '_': 20, '[': 20, ']': 20, '{': 20, '}': 20, '(': 20, ')': 20, '\n': 20, '\r': 20, 'space': 20},
    6:  {'letra': 7,  'num': 8,  'noSigma': 50, 'EOF': 50, '+': 51, '-': 51, '*': 51, '/': 51, '<': 51, '=': 51, '>': 51, ':': 51, ';': 51, ',': 51, '\'': 51, '.': 51, '_': 51, '[': 51, ']': 51, '{': 51, '}': 51, '(': 51, ')': 51, '\n': 51, '\r': 51, 'space': 51},
    7:  {'letra': 7,  'num': 8,  'noSigma': 52, 'EOF': 52, '+': 21, '-': 21, '*': 21, '/': 21, '<': 21, '=': 21, '>': 21, ':': 21, ';': 21, ',': 21, '\'': 21, '.': 21, '_': 6,  '[': 21, ']': 21, '{': 21, '}': 21, '(': 21, ')': 21, '\n': 21, '\r': 21, 'space': 21},
    8:  {'letra': 7,  'num': 8,  'noSigma': 53, 'EOF': 53, '+': 21, '-': 21, '*': 21, '/': 21, '<': 21, '=': 21, '>': 21, ':': 21, ';': 21, ',': 21, '\'': 21, '.': 21, '_': 6,  '[': 21, ']': 21, '{': 21, '}': 21, '(': 21, ')': 21, '\n': 21, '\r': 21, 'space': 21},
    9:  {'letra': 55, 'num': 55, 'noSigma': 54, 'EOF': 54, '+': 55, '-': 55, '*': 10, '/': 55, '<': 55, '=': 55, '>': 55, ':': 55, ';': 55, ',': 55, '\'': 55, '.': 55, '_': 55, '[': 55, ']': 55, '{': 55, '}': 55, '(': 55, ')': 55, '\n': 55, '\r': 55, 'space': 55},
    10: {'letra': 10, 'num': 10, 'noSigma': 10, 'EOF': 56, '+': 10, '-': 10, '*': 11, '/': 10, '<': 10, '=': 10, '>': 10, ':': 10, ';': 10, ',': 10, '\'': 10, '.': 10, '_': 10, '[': 10, ']': 10, '{': 10, '}': 10, '(': 10, ')': 10, '\n': 10, '\r': 10, 'space': 10},
    11: {'letra': 10, 'num': 10, 'noSigma': 10, 'EOF': 56, '+': 10, '-': 10, '*': 10, '/': 10, '<': 10, '=': 10, '>': 10, ':': 10, ';': 10, ',': 10, '\'': 10, '.': 10, '_': 10, '[': 10, ']': 10, '{': 10, '}': 10, '(': 10, ')': 22, '\n': 10, '\r': 10, 'space': 10},
    12: {'letra': 12, 'num': 12, 'noSigma': 12, 'EOF': 58, '+': 12, '-': 12, '*': 12, '/': 12, '<': 12, '=': 12, '>': 12, ':': 12, ';': 12, ',': 12, '\'': 12, '.': 12, '_': 12, '[': 12, ']': 12, '{': 57, '}': 23, '(': 57, ')': 12, '\n': 57, '\r': 57, 'space': 12},
    13: {'letra': 24, 'num': 24, 'noSigma': 59, 'EOF': 59, '+': 24, '-': 24, '*': 24, '/': 24, '<': 24, '=': 25, '>': 26, ':': 24, ';': 24, ',': 24, '\'': 24, '.': 24, '_': 24, '[': 24, ']': 24, '{': 24, '}': 24, '(': 24, ')': 24, '\n': 24, '\r': 24, 'space': 24},
    14: {'letra': 27, 'num': 27, 'noSigma': 60, 'EOF': 60, '+': 27, '-': 27, '*': 27, '/': 27, '<': 27, '=': 28, '>': 27, ':': 27, ';': 27, ',': 27, '\'': 27, '.': 27, '_': 27, '[': 27, ']': 27, '{': 27, '}': 27, '(': 27, ')': 27, '\n': 27, '\r': 27, 'space': 27},
    15: {'letra': 30, 'num': 30, 'noSigma': 61, 'EOF': 61, '+': 30, '-': 30, '*': 30, '/': 30, '<': 30, '=': 31, '>': 30, ':': 30, ';': 30, ',': 30, '\'': 30, '.': 30, '_': 30, '[': 30, ']': 30, '{': 30, '}': 30, '(': 30, ')': 30, '\n': 30, '\r': 30, 'space': 30},
    16: 'string',
    17: '-',
    18: 'num',
    19: '..',
    20: 'real',
    21: 'identifier',
    22: 'comentarios',
    23: 'comentario',
    24: '<',
    25: '<=', 
    26: '<>',
    27: '>', 
    28: '>=', 
    29: '=',
    30: ':',
    31: ':=',
    32: '+',
    33: '*',
    34: '/',
    35: ';',
    36: ',',
    37: '.',
    38: '[',
    39: ']',
    40: '}',
    41: ')',
    42: 'ERROR: ',
    43: 'ERROR: ',
    44: 'ERROR: ',
    45: 'ERROR: ',
    46: 'ERROR: ',
    47: 'ERROR: ',
    48: 'ERROR: ',
    49: 'ERROR: ',
    50: 'ERROR: ',
    51: 'ERROR: ',
    52: 'ERROR: ',
    53: 'ERROR: ',
    54: 'ERROR: ',
    55: 'ERROR: ',
    56: 'ERROR: ',
    57: 'ERROR: ',
    58: 'ERROR: ',
    59: 'ERROR: ',
    60: 'ERROR: ',
    61: 'ERROR: ',
} 

tokenID = { #DICCIONARIO DE LAS PALABRAS CLAVES
    "program": "1",
    "real": "2",
    "repeat": "3",
    "procedure": "4",
    "string": "5",
    "until": "6",
    "function": "7",
    "array": "8",
    "for": "9",
    "begin": "10",
    "of": "11",
    "to": "12",
    "end": "13",
    "if": "14",
    "do": "15",
    "var": "16",
    "then": "17",
    "readLn": "18",
    "integer": "19",
    "else": "20",
    "writeLn": "21",
    "+": "22",
    "-": "23",
    "*": "24",
    "/": "25",
    "<": "26",
    "<=": "27",
    ">": "28",
    ">=": "29",
    "=": "30",
    "<>": "31",
    ":=": "32",
    ":": "33",
    ";": "34",
    ",": "35",
    ".": "36",
    "(": "37",
    ")": "38",
    "[": "39",
    "]": "40",
    "{": "41",
    "}": "42",
    "(*": "43",
    "*)": "44",
    "\'" : "45",
    "identifier" : "47",
    "num": "48",
    "comentarios" : "49",
    "comentario" : "50",
    "real" : "51",
    "noSigma" : "52"
}

def aceptor(estado: int): # DETERMINA SI ES UN ESTADO ACEPTOR 
    return estado >= 16 and estado <= 41  # DEL ESTADO 16 AL 41 

def error(estado: int): # DETERMINA SI ES UN ESTADO DE ERROR 
    return estado >= 42 and estado <= 61 # DEL ESTADO 43 AL 61 
    
def tipo(caracter): # DETERMINA EL TIPO DE CARACTER
    if caracter.isalpha(): # ISALPHA = LETRAS
        return 'letra'
    elif caracter.isdigit(): # ISDIGIT = NÚMEROS
        return 'num'
    elif caracter in ['{', '}', '[', ']', '(', ')', ';', ',', ':', '.', '+', '-', '*', '/', '\'']: # SÍMBOLOS 
        return caracter  
    elif caracter in ['\n', '\r', '\t', ' ']: # SÍMBOLOS ESPECIFICOS DE ESPACIO 
        return 'space'  
    else:                               
        return 'noSigma'  #SÍMBOLOS DIFERENTES A SIGMA COMO #
    
def siguiente_caracter(codigo: str, index: int): # REGRESA EL SIGUIENTE CARACTER DE LA CADENA DE ENTRADA BASANDOSE EN UN INDICE. RECIBE LA CADENA DE TEXTO Y LA POSICIÓN ACTUAL DEL CARACTER
    return codigo[index] # RETORNO DEL CARACTER UBICADO EN LA POSICIÓN ESPECIFICADA POR INDEX

def numero_real(decimal): #TOMA DE ARGUMENTO DECIMAL PARA GUARDAR LA CADENA QUE CONTIENE EL NÚMERO REAL
    try:  # CONVIERTE LA CADENA (decimal) A UN NÚMERO REAL .........  | LA USE PORQUE TENÍA PROBLEMAS PARA LANZAR EL TOKEN REAL  ( TRY lanza una excepción debido a un error durante su ejecución)
        float(decimal)  #USANDO LA FUNCIÓN FLOAT
        return '.' in decimal  #VERIFICA QUE HAYA UN PUNTO Y ASÍ SE ASEGURA DE QUE SEA UN NÚMERO DECIMAL
    except ValueError: #  La cláusula except captura cualquier ValueError generado en el bloque try. Un ValueError ocurre si float(decimal) falla debido a que decimal no es convertible a flotante.
        return False  # SI NO ES UN NÚMERO REAL, REGRESA FALSE

def scanner(codigo: str):  #CORAZÓN DEL COMPILADOR | TOMA LA CADENA DE TEXTO (codigo) DE TIPO STRING
    index = 0 # CONTADOR PARA SEGUIR LA POSICIÓN ACTUAL DENTRO DE LA CADENA (codigo) | SE INICIALIZA EN 0 PORQUE INICIA DESDE EL PRIMER CARACTER DE LA CADENA
    estado = 0  # ESTADOS DE LA TABLA DE TRANSICIONES | SE INICIALIZA EN 0 PORQUE LA TABLA EMPIEZA DESDE EL ESTADO 0
    token = '' # CADENA DE TEXTO DONDE SE ACOMULAN LOS CARACTERES | SE INICIALIZA VACIA PORQUE AÚN NO SE ESCANEA NADA
    en_comentario = False # ¿ESTA EL ESCANER ACTUALMENTE DENTRO DE UN COMENTARIO?
    comentario_abierto = None # ANALIZA HASTA QUE EL COMENTARIO SEA CERRADO

    while index < len(codigo): # MIENTRAS EL ÍNDICE SEA MENOR QUE LA LONGITUD TORAL DEL CÓDIGO FUENTE
        caracter = siguiente_caracter(codigo, index) # DEVUELVE EL CARACTER EN LA POSICIÓN ACTUAL DEL ÍNDICE DENTRO DE LA CADENA (codigo).
        tipo_caracter = tipo(caracter)  # DEVUELVE EL TIPO DE CARACTER 

        if en_comentario: # SI ESTAMOS ESCANEANDO UN COMENTAARIO 
            if (comentario_abierto == '{' and caracter == '}') or \
               (comentario_abierto == '(*' and caracter == '*' and siguiente_caracter(codigo, index + 1) == ')'):
                en_comentario = False # SI SE ENCONTRO '}' O '*)' INDICA QUE YA SE LEYÓ EL COMENTARIO COMPLETO Y YA NO ESTA EN UN COMENTARIO
                comentario_abierto = None # NO HAY NINGÚN COMENTARIO ABIERTO
                index += 2 if caracter == '*' else 1 # SI EL COMENTARIO CERRADO FUE *), SE INCREMENTA EN 2 PARA PASAR POR ALTO * Y ).
                continue
            index += 1  # SI FUE }, SOLO SE INCREMENTA EN 1.
            continue

        if tipo_caracter in tabla[estado]: # SI EL TIPO DE CARACTER ACTUAL ES UNA CLAVE VALIDA EN LA TABLA DE TRANSICIONES (tabla)
            siguiente_estado = tabla[estado][tipo_caracter] # SE ASIGNA EL NUEVO ESTADO

            if aceptor(siguiente_estado): # SI ES UN ESTADO ACEPTOR
                if token.strip():  #VERIFICA SI EXISTE EL TOKEN
                    if numero_real(token):  # SI EL TOKEN ES UN NÚMERO REAL
                        yield "token: real"   # SE EMITE COMO TOKEN REAL
                    elif token.isdigit():    # SI EL TOKEN ES UN NÚMERO ENTERO
                        yield "token: num"  #SE EMITE COMO UN TOKEN  NUM
                    elif token.strip().isalpha() and len(token.strip()) == 1: # SI EL TOKEN ES UNA LETRA
                        yield "token: letra"  #SE EMITE COMO LETRA
                    else:
                        yield f"token: {token.strip()}"  # SI EL TOKEN NO CUMPLE LAS ANTERIORES CONDICIONES SE EMITE TAL CUAL ESTA
                token = ''  # SE LIMPIA LA VARIABLE TOKEN PARA EMPEZAR DE NUEVO
                estado = 0  # SE LIMPIA EL ESTADO PARA EMPEZAR DE NUEVO


            elif error(siguiente_estado): # SI ES UN ESTADO DE ERROR
                yield "token: EOF"  #EMITE EL TOKEN EOF
                token = '' # SE LIMPIA LA VARIABLE TOKEN PARA EMPEZAR DE NUEVO
                estado = 0 # SE LIMPIA EL ESTADO PARA EMPEZAR DE NUEVO


            else: # SI ES UN ESTADO DE TRANSICIÓN
                token += caracter  # SE ACOMULA EL CARACTER ACTUAL EN LA VARIABLE TOKEN
                estado = siguiente_estado  #SE ACTUALIZA EL ESTADO PARA EL CARACTER ACTUAL
        else:
            if tipo_caracter == 'noSigma':  # SI EL CARACTER NO ES RECONOCIDO (NO SIGMA)
                yield "token: noSigma"   # EMITE EL TOKEN NO SIGMA
           

# CÓDIGO PRUEBA
codigo_prueba = """ { Example #1 }
{ This is the typical "Hello World" }
program HelloWorld;
(* This is the main program block *)
begin
writeLn( ' Hello World ' );
end. (* This is the end of the main
program block *)"""

resultado = scanner(codigo_prueba) # SE LLAMA LA FUNCIÓN SCANNER CON LA CADENA DE TEXTO CON LA QUE SE VA A EVALUAR Y SE RENOMBRA POR RESULTADO
for token in resultado: # BUCLE PARA VER LOS RESULTADOS
    print(f"Token: {token}") # SE IMPRIME LA PALABRA TOKEN Y EL TOKENID